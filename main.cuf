! Thi program is to compute the solution of INS Equation for HIT problem
! in a periodic box using pseudo spectral method, with Adam bashforth and Crank Nicholsan
! for time integration.
program main
  use cudafor
  use cu_fft
  use cu_fft_module
  implicit none

  !character(len=16) :: filename
  
  ! Arrays in physical space
  real(kind=c_float), managed:: ux(n, n, n), uy(n, n, n), uz(n, n, n)
  integer ierr
  real(kind=c_float), managed :: vortx_ini(n, n, n), vorty_ini(n, n, n), vortz_ini(n, n, n)
  real(kind=c_float), managed :: vortx(n, n, n), vort(n, n, n), vortz(n, n, n)
  real(kind=c_float), managed :: velvortx(n, n, n), velvorty(n, n, n), velvortz(n, n, n)

  ! Arrays in spectral space
  complex(kind=c_float_complex), managed :: ux_hat(nhp, ny, nz), uy_hat(nhp, ny, nz), uz_hat(nhp, ny, nz)
  complex(kind=c_float_complex), managed :: ux_hat_1(nhp, ny, nz), uy_hat_1(nhp, ny, nz), uz_hat_1(nhp, ny, nz)
  complex(kind=c_float_complex), managed :: omegax_hat(nhp, ny, nz), omegay_hat(nhp, ny, nz), omegaz_hat(nhp, ny, nz) !vorticity: ω
  complex(kind=c_float_complex), managed :: vomegax_hat(nhp, ny, nz), vomegay_hat(nhp, ny, nz), vomegaz_hat(nhp, ny, nz) ! u × ω
  complex(kind=c_float_complex), managed :: rhsx_prev_hat(nhp, ny, nz), rhsy_prev_hat(nhp, ny, nz), rhsz_prev_hat(nhp, ny, nz)  ! RHS = F(u); stage Storage
  complex(kind=c_float_complex), managed :: rhsx_hat(nhp, ny, nz), rhsy_hat(nhp, ny, nz), rhsz_hat(nhp, ny, nz)    ! RHS = F(u) Running storage

  !  ! Wavenumber related arrays
  real(kind=c_float), managed :: kx(nhp, ny, nz), ky(nhp, ny, nz), kz(nhp, ny, nz), k2(nhp, ny, nz), k2inv(nhp, ny, nz), kabs(nhp, ny, nz)

  integer, managed :: id_absk(nhp, ny, nz)
  real(kind=c_float), managed :: pi
  real(kind=c_float), managed :: pi2
  
  ! Kinematic viscosity
  real(kind=c_float), managed :: visc 
  
  real(kind=c_float), managed :: dx, dy, dz
  integer, managed :: istep

  !  ! Number of timesteps
  integer, parameter :: nsteps = 2000
  real(kind=c_float), managed :: energy, energy_0, norm_energy

  !  output to be written
  integer, parameter :: ndump = 50
  
  ! Output to ASCII files every ... steps
  integer, parameter :: noutput = 50

  ! \Delta
  real(kind=c_float), parameter :: dt = 0.005

  ! Spectral truncation  for dealiasing
  real(8), managed :: klimit = nx/3.

  ! Benchnark timing and counters
  real :: start, finish
  integer :: i, j, k
  integer :: stat_fplan, stat_iplan, plan, inv_plan


  pi = 4.0*atan(1.0)
  pi2 = 2*pi
  visc = 1/300.
 
  
  dx = pi2/nx
  dy = pi2/ny
  dz = pi2/nz


  !  ! Initialize velocity field according to the Taylor-Green Vortex case
  call initial_condition(n, ux, uy, uz)
  call initial_vorticity(n, vortx_ini, vorty_ini, vortz_ini)
  call compute_wavenumbers(n, nhp, kx, ky, kz, k2, k2inv, kabs, id_absk)

  ierr= cudaDeviceSynchronize()
  print *, "ux is: ", ux(1:2, 1:2, 1:2)
  print *, "ux is: ", vortx_ini(1:2, 1:2, 1:2)

  stat_fplan = cufftPlan3d(plan, nx, ny, nz, CUFFT_R2C)

 if ( stat_fplan /= CUFFT_SUCCESS) then
   print *,  "Forward Plan Did not initialize!"
 endif
stat_iplan = cufftPlan3d(inv_plan, nx, ny, nz, CUFFT_C2R)

if ( stat_iplan= CUFFT_SUCCESS) then
  print *,  "Inverse  Plan Did not initialize!"
endif


  
  
  !  !call vtk_output(vortx_ini, dx, dy, dz)
  

  !  call fft_forward_execute(ux, ux_hat, plan_f)
  !  call fft_forward_execute(uy, uy_hat, plan_f)
  !  call fft_forward_execute(uz, uz_hat, plan_f)

  !  energy_0 = 0.5*sum(ux**2 + uy**2 + uz**2)/nxyz
  !  print *, minval(id_absk)
  !  print *, "klimit", klimit
  !  ! Open text file for writing out energy
  !  open (unit=10, file='ke.txt', status='replace', action='write')

  !  !write(10, '(A)') 'i    t    ke'

  !  !------------------------------------------------------------
  !  ! Driver loop
  !  !------------------------------------------------------------

  !  call cpu_time(start)

  !  do istep = 1, nsteps
  !     print '(A, 1X, I4, 1X, A, I4)', 'Time Step', istep, 'Total steps', nsteps
  !     ux_hat_1 = ux_hat
  !     uy_hat_1 = uy_hat
  !     uz_hat_1 = uz_hat

  !     call fft_inverse_execute(ux_hat_1, ux, plan_b)
  !     call fft_inverse_execute(uy_hat_1, uy, plan_b)
  !     call fft_inverse_execute(uz_hat_1, uz, plan_b)

  !     energy = 0.5*sum(ux**2 + uy**2 + uz**2)/nxyz

  !     norm_energy = energy/energy_0
  !     write (10, '(I4, 1X, 1PE14.6, 1X, 1PE14.6)') istep, istep*dt, norm_energy
  !     do k = 1, nz
  !        do j = 1, ny
  !           do i = 1, nhp
  !              omegax_hat(i, j, k) = cmplx(0, 1)*(ky(i, j, k)*uz_hat(i, j, k) - kz(i, j, k)*uy_hat(i, j, k))
  !              omegay_hat(i, j, k) = cmplx(0, 1)*(kz(i, j, k)*ux_hat(i, j, k) - kx(i, j, k)*uz_hat(i, j, k))
  !              omegaz_hat(i, j, k) = cmplx(0, 1)*(kx(i, j, k)*uy_hat(i, j, k) - ky(i, j, k)*ux_hat(i, j, k))
  !           end do
  !        end do
  !     end do

  !     call fft_inverse_execute(omegax_hat, vortx, plan_b)
  !     call fft_inverse_execute(omegay_hat, vorty, plan_b)
  !     call fft_inverse_execute(omegaz_hat, vortz, plan_b)

  !     do k = 1, nz
  !        do j = 1, ny
  !           do i = 1, nx
  !              velvortx(i, j, k) = uy(i, j, k)*vortz(i, j, k) - uz(i, j, k)*vorty(i, j, k)
  !              velvorty(i, j, k) = uz(i, j, k)*vortx(i, j, k) - ux(i, j, k)*vortz(i, j, k)
  !              velvortz(i, j, k) = ux(i, j, k)*vorty(i, j, k) - uy(i, j, k)*vortx(i, j, k)
  !           end do
  !        end do
  !     end do

  !     !print *, 'rec_curl', velvortx(1:2, 1:2, 1:2)

  !     call fft_forward_execute(velvortx, vomegax_hat, plan_f)
  !     call fft_forward_execute(velvorty, vomegay_hat, plan_f)
  !     call fft_forward_execute(velvortz, vomegaz_hat, plan_f)

  !     ! Dealias Mode
  !     do k = 1, nz
  !        do j = 1, ny
  !           do i = 1, nhp
  !              if (id_absk(i, j, k) > klimit) then
  !                 vomegax_hat(i, j, k) = 0.0
  !                 vomegay_hat(i, j, k) = 0.0
  !                 vomegaz_hat(i, j, k) = 0.0
  !              end if
  !           end do
  !        end do
  !     end do

  !     ! Compute RHS

  !     do k = 1, nz
  !        do j = 1, ny
  !           do i = 1, nhp
  !              rhsx_hat(i, j, k) = &
  !                 vomegax_hat(i, j, k) - &
  !                 visc*k2(i, j, k)*ux_hat(i, j, k) - &
  !                 kx(i, j, k)*k2inv(i, j, k)* &
  !                 (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
  !                  + kz(i, j, k)*vomegaz_hat(i, j, k))

  !              rhsy_hat(i, j, k) = &
  !                 vomegay_hat(i, j, k) - &
  !                 visc*k2(i, j, k)*uy_hat(i, j, k) - &
  !                 ky(i, j, k)*k2inv(i, j, k)* &
  !                 (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
  !                  + kz(i, j, k)*vomegaz_hat(i, j, k))

  !              rhsz_hat(i, j, k) = &
  !                 vomegaz_hat(i, j, k) - &
  !                 visc*k2(i, j, k)*uz_hat(i, j, k) - &
  !                 kz(i, j, k)*k2inv(i, j, k)* &
  !                 (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
  !                  + kz(i, j, k)*vomegaz_hat(i, j, k))
  !           end do
  !        end do
  !     end do

  !     ! Stage storage for time integrator at first step

  !     if (istep == 1) then
  !        rhsx_prev_hat = vomegax_hat
  !        rhsy_prev_hat = vomegay_hat
  !        rhsz_prev_hat = vomegaz_hat
  !     end if

  !     ! Time integrate

  !     call ab_time_integrator(nhp, nx, ny, dt, ux_hat, uy_hat, uz_hat, &
  !                             rhsx_prev_hat, rhsy_prev_hat, rhsz_prev_hat, &
  !                             rhsx_hat, rhsy_hat, rhsz_hat)

  !     ! Stage Storage for AB Integrator
  !     rhsx_prev_hat = rhsx_hat
  !     rhsy_prev_hat = rhsy_hat
  !     rhsz_prev_hat = rhsz_hat

  !  end do

  !  call fft_cleanup(plan_f)
  !  call fft_cleanup(plan_b)
  !  deallocate (ux, uy, uz)
  !  deallocate (vortx_ini, vorty_ini, vortz_ini)

  !  call cpu_time(finish)
  !  write (*, "(A, 1X, 1pe14.6)") 'elased_time:', finish - start

  ! close (10)
end program main

