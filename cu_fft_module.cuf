module cu_fft_module
   use cudafor
   implicit none
   private
   public :: initial_condition, initial_vorticity, compute_wavenumbers, compute_rhs
   public :: ab_time_integrator !, RK45_time_integrator, SSP_time_integrator
   public :: vtk_output
contains
   subroutine initial_condition(n, ux, uy, uz)
      real(kind=c_float), managed, intent(inout) :: ux(n, n, n), uy(n, n, n), uz(n, n, n)
      integer, intent(in) :: n
      integer :: i, j, k
      real(kind=c_float) :: dx, dy, dz

      real(kind=c_float), parameter :: pi = 3.1415927410125732
      real(kind=c_float), parameter :: pi2 = 2*pi

      dx = pi2/n
      dy = pi2/n
      dz = pi2/n

      !$cuf kernel do(3) <<< (*, *), (32, 4) >>>
      do k = 1, n
         do j = 1, n
            do i = 1, n
               ux(i, j, k) = sin((i - 0.5)*dx)*cos((j - 0.5)*dy)*cos((k - 0.5)*dz)
               uy(i, j, k) = -cos((i - 0.5)*dx)*sin((j - 0.5)*dy)*cos((k - 0.5)*dz)
               uz(i, j, k) = 0.0 !
            end do
         end do
      end do
   end subroutine initial_condition


   subroutine initial_vorticity(n, vortx, vorty, vortz)
     real(kind=c_float), managed, intent(inout) :: vortx(n, n, n), vorty(n, n, n), vortz(n, n, n)
     integer, intent(in) :: n
     integer :: i, j, k
     real(kind=c_float) :: dx, dy, dz
     real(kind=c_float), parameter :: pi = 3.1415927410125732
     real(kind=c_float), parameter :: pi2 = 2*pi

      dx = pi2/n
      dy = pi2/n
      dz = pi2/n

      !$cuf kernel do(3) <<< (*, *), (32, 4) >>>
      do k = 1, n
      do j = 1, n
         do i = 1, n
            vortx(i, j, k) = -cos((i - 0.5)*dx)*sin((j - 0.5)*dy)*sin((k - 0.5)*dz)
            vorty(i, j, k) = -sin((i - 0.5)*dx)*cos((j - 0.5)*dy)*sin((k - 0.5)*dz)
            vortz(i, j, k) = sin((i - 0.5)*dx)*sin((j - 0.5)*dy)*cos((k - 0.5)*dz) &
                                 + sin((i - 0.5)*dx)*sin((j - 0.5)*dy)*cos((k - 0.5)*dz)
         end do
      end do
   end do
   end subroutine initial_vorticity


   subroutine compute_wavenumbers(n, nhp, kx, ky, kz, k2, k2inv, kabs, ind_k2)
     integer, intent(in) :: n
     integer, intent(in) :: nhp
     real(kind=c_float), managed, intent(inout) :: kx(nhp, n, n), ky(nhp, n, n), kz(nhp, n, n)
     real(kind=c_float), managed, intent(inout) :: k2(nhp, n, n), k2inv(nhp, n, n), kabs(nhp, n, n)
     integer, managed, intent(inout):: ind_k2(nhp, n, n)
     integer :: i, j, k

   
    do i = 1, nhp
      if (i <= n/2) then
        kx(i, :, :) = i - 1
      else
        kx(i, :, :) = -n + i - 1
      end if
    end do


    do j = 1, n
      if (j <= n/2) then
        ky(:, j, :) = j - 1
      else
        ky(:, j, :) = -n + j - 1
      end if
    end do

    do k = 1, n
      if (k <= n/2) then
        kz(:, :, k) = k - 1
      else
        kz(:, :, k) = -n + k - 1
      end if
    end do

    do k = 1, n
      do j = 1, n
        do i = 1, nhp
          k2(i, j, k) = kx(i, j, k)**2 + ky(i, j, k)**2 + kz(i, j, k)**2
          ind_k2(i, j, k) = int(sqrt(k2(i, j, k)) + 0.5)
          kabs(i, j, k) = sqrt(k2(i, j, k))
          if (k2(i, j, k) /= 0) then
            k2inv(i, j, k) = 1.0/k2(i, j, k)
          else
            k2inv(i, j, k) = 1.0
          end if
        end do
      end do
    end do
  end subroutine compute_wavenumbers

  subroutine compute_rhs(nhp, ny, nz, visc, rhsx_hat, rhsy_hat, rhsz_hat, &
                         vomegax_hat, vomegay_hat, vomegaz_hat, ux_hat, uy_hat, uz_hat, &
                         kx, ky, kz, k2, k2inv &
                         )

    integer, intent(in) :: nhp,  ny, nz
    real(kind=c_float), managed, intent(in) :: kx(nhp, ny, nz), ky(nhp, ny, nz), kz(nhp, ny, nz), k2(nhp, ny, nz), k2inv(nhp, ny, nz)
    complex(kind=c_float_complex), managed, intent(inout) :: rhsx_hat(nhp, ny, nz), rhsy_hat(nhp, ny, nz), rhsz_hat(nhp, ny, nz)
    complex(kind=c_float_complex), managed, intent(in) :: vomegax_hat(nhp, ny, nz), vomegay_hat(nhp, ny, nz), vomegaz_hat(nhp, ny, nz)

    complex(kind=c_float_complex), managed, intent(in) :: ux_hat(nhp, ny, nz), uy_hat(nhp, ny, nz), uz_hat(nhp, ny, nz)
    real(kind=c_float) :: visc
    
    integer :: i, j, k
    

    !$cuf kernel do(3) <<< (*, *), (32, 4)>>>
    do k = 1, nz
         do j = 1, ny
            do i = 1, nhp
               rhsx_hat(i, j, k) = &
                  vomegax_hat(i, j, k) - &
                  visc*k2(i, j, k)*ux_hat(i, j, k) - &
                  kx(i, j, k)*k2inv(i, j, k)* &
                  (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
                   + kz(i, j, k)*vomegaz_hat(i, j, k))

               rhsy_hat(i, j, k) = &
                  vomegay_hat(i, j, k) - &
                  visc*k2(i, j, k)*uy_hat(i, j, k) - &
                  ky(i, j, k)*k2inv(i, j, k)* &
                  (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
                   + kz(i, j, k)*vomegaz_hat(i, j, k))

               rhsz_hat(i, j, k) = &
                  vomegaz_hat(i, j, k) - &
                  visc*k2(i, j, k)*uz_hat(i, j, k) - &
                  kz(i, j, k)*k2inv(i, j, k)* &
                  (kx(i, j, k)*vomegax_hat(i, j, k) + ky(i, j, k)*vomegay_hat(i, j, k) &
                   + kz(i, j, k)*vomegaz_hat(i, j, k))
            end do
         end do
      end do


  end subroutine compute_rhs
 

   subroutine ab_time_integrator( &
      nhp, ny, nz, dt, &
      ux_hat, uy_hat, uz_hat, &
      rhsx_prev_hat, rhsy_prev_hat, rhsz_prev_hat, &
      rhsx_hat, rhsy_hat, rhsz_hat)
      
      integer, intent(in) :: nhp, ny, nz
      real(kind=c_float), intent(in) :: dt
      complex(kind=c_float_complex), managed, intent(inout) :: ux_hat(nhp, ny, nz), uy_hat(nhp, ny, nz), uz_hat(nhp, ny, nz)
      complex(kind=c_float_complex), managed, intent(in) :: rhsx_prev_hat(nhp, ny, nz), rhsy_prev_hat(nhp, ny, nz), rhsz_prev_hat(nhp, ny, nz)
      complex(kind=c_float_complex), managed, intent(in) :: rhsx_hat(nhp, ny, nz), rhsy_hat(nhp, ny, nz), rhsz_hat(nhp, ny, nz)
      integer :: i, j, k

     
      !$cuf kernel do(3) <<< (*, *), (32, 4) >>>
      do k = 1, nz
         do j = 1, ny
            do i = 1, nhp
               ux_hat(i, j, k) = ux_hat(i, j, k) + 0.5*dt*(3*rhsx_hat(i, j, k) - rhsx_prev_hat(i, j, k))
               uy_hat(i, j, k) = uy_hat(i, j, k) + 0.5*dt*(3*rhsy_hat(i, j, k) - rhsy_prev_hat(i, j, k))
               uz_hat(i, j, k) = uz_hat(i, j, k) + 0.5*dt*(3*rhsz_hat(i, j, k) - rhsz_prev_hat(i, j, k))
            end do
         end do
      end do
   end subroutine ab_time_integrator

   ! subroutine RK45_time_integrator()
   !    print *, "in time integration"
   ! end subroutine RK45_time_integrator

   ! subroutine SSP_time_integrator()
   !    print *, "in time integration"
   ! end subroutine SSP_time_integrator

   subroutine vtk_output(sol_field, dx, dy, dz, nx, ny, nz)
      real(kind=c_float), managed, intent(in) :: sol_field(nx, ny, nz)
      real, intent(in):: dx, dy, dz
      integer, intent(in) :: nx, ny, nz
      integer :: i, j, k
      integer :: unit

      character(len=50) :: output_file
      character(len=50) :: filename
      !character(len=50) :: ext
      
      !ext = ".vts"
      !output_file = filename//ext
      

      
      write (filename, "('field',i5.5,'.plt')") 10
      open (unit=100, file=filename, status="replace")

      write (100, *) 'TITLE = "3D-Volume Data"'
      write (100, *) 'VARIABLES = "X", "Y", "Z", "U"'
      write (100, "('ZONE I=',i4,1x,', J=',i4,1x,', K=',i4,1x,'F=POINT')") nx, ny, nz
      do k = 1, nx
         do j = 1, ny
            do i = 1, nz
               write (100, '(3(f8.5,2x), 1pe15.7, 2x)') &
                  (i - 0.5)*dx, (j - 0.5)*dy, (k - 0.5)*dz, &
                  sol_field(i, j, k)
            end do
         end do
      end do
      close (unit)
      print *, "finished writing file: ", trim(filename)

   end subroutine vtk_output

end module cu_fft_module

